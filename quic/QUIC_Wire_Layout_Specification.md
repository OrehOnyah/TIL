# QUIC Wire Layout Specification
## 원본
[https://docs.google.com/document/d/1WJvyZflAO2pq77yOLbp9NsGjC1CHetAXV8I0fQe-B_U/edit?usp=sharing](https://docs.google.com/document/d/1WJvyZflAO2pq77yOLbp9NsGjC1CHetAXV8I0fQe-B_U/edit?usp=sharing)  

## 목차
- [Introduction](#Introduction)
- [Conventions and Definitions](#Conventions-and-Definitions)
- [A QUIC Overview](#A-QUIC-Overview)
## Introduction
QUIC(Quick UDP Internet Connection)는 UDP 상단의 새로운 멀티플렉스 및 보안 전송으로, 처음부터 설계되어 HTTP/2 의미론용으로 최적화되었다. QUIC는 HTTP/2를 주 애플리케이션 프로토콜로 구축하면서 수십 년의 전송 및 보안 경험을 토대로 구축되며, 현대의 범용 전송으로서 매력적으로 만드는 메커니즘을 구현한다. QUIC는 HTTP/2에 상당하는 멀티플렉싱과 흐름 제어, TLS에 상당하는 보안, TCP에 상당하는 연결 의미론, 신뢰성, 정체 제어 등을 제공한다.  

QUIC는 전적으로 사용자 공간에서 작동하며, 현재 크롬 브라우저의 일부로 사용자에게 배송되어 신속한 전개와 실험을 가능하게 한다. UDP 상단의 사용자 공간 전송으로서 QUIC는 기존 클라이언트와 미들박스 또는 운영 체제 개발 및 구축 주기의 장기화로 인해 기존 프로토콜로 구현하기 어려운 것으로 입증된 혁신을 허용한다.  

QUIC의 중요한 목표는 신속한 실험을 통해 더 나은 운송 설계를 알리는 것이다. 그 결과, 우리는 증류주기가 훨씬 더 긴 경향이 있는 TCP와 TLS로 가능한 한 변경사항을 알려주고, 또 어디로 이동시키기를 희망한다. 

본 문서는 표준화 이전에 QUIC 프로토콜의 개념 설계와 와이어 사양을 설명한다. 통합 문서에는 암호 및 전송 핸드셰이크[QUIC-CRYPTO]와 손실 복구 및 정체 관리[draft-yengar-quic-loss-recovery]가 기술되어 있다. 좀 더 자세한 근거 문서를 포함한 추가 자원은 Chromium QUIC 웹 페이지에서 이용할 수 있다.  

이러한 조기 배치에 기초한 QUIC의 표준화 제안은 [draft-hamilton-quic-transport-protocol], [draft-shade-quic-http2-mapping], [draft-yengar-quic-lossion-ls]이다.  

## Conventions and Definitions
길이, 버전, 유형을 포함하여 QUIC에 사용되는 모든 정수 값은 little-endian 바이트 순서로 되어 있으며, 네트워크 바이트 순서가 아니다. QUIC는 동적인 크기의 프레임의 형식 정렬을 강제하지 않는다.  

이 문서 전체에 사용되는 몇 가지 용어는 아래에 정의되어 있다.  
- "클라이언트": QUIC 연결을 시작하는 엔드포인트.  
- "서버": 들어오는 QUIC 연결을 허용하는 끝점.  
- "끝점": 연결의 클라이언트 또는 서버 끝.  
- "Stream": QUIC 연결 내의 논리적 채널을 통과하는 양방향 바이트 흐름.  
- "연결": 두 QUIC 끝점 간의 대화로서, 그 안에서 스트림을 멀티플렉싱하는 단일 암호화 컨텍스트를 가지고 있다.  
- "연결 ID": QUIC 연결의 식별자.  
- "QUIC 패킷": QUIC 수신기로 구문 분석할 수 있는 잘 구성된 UDP 페이로드. 이 문서의 QUIC 패킷 크기는 UDP 페이로드 크기를 가리킨다.  

## A QUIC Overview
이제 QUIC의 핵심 메커니즘과 이점을 간략하게 설명하겠다. QUIC는 기능적으로는 TCP+TLS+HTTP/2에 상당하지만 UDP 위에 구현된다. TCP+TLS+HTTP/2에 비해 QUIC의 주요 장점은 다음과 같다.  
- 연결 설정 지연 시간
- 유연한 정체 제어
- 헤드오프라인이 차단되지 않은 멀티플렉싱
- 인증 및 암호화된 헤더 및 페이로드
- 스트림 및 연결 흐름 제어
- 연결 마이그레이션

### Connection Establishment Latency

QUIC는 암호화와 운반 핸드셰이크를 결합하여 안전한 연결을 설정하는 데 필요한 원형 트립의 수를 줄인다. QUIC 연결은 일반적으로 0-RTT이며, 이는 대부분의 QUIC 연결에서 응용 프로그램 데이터를 전송하기 전에 TCP+TLS에 필요한 1-3개의 라운드 트립과 비교하여 서버의 회신을 기다리지 않고 바로 데이터를 전송할 수 있음을 의미한다.

QUIC는 핸드셰이크 수행에 사용할 전용 스트림(Stream ID 1)을 제공하지만, 이 핸드셰이크 프로토콜의 세부사항은 이 문서의 범위를 벗어난다. 현재 핸드셰이크 프로토콜에 대한 자세한 설명은 QUIC Crypto Handshake 문서를 참조하십시오. QUIC 전류 악수는 향후 TLS 1.3으로 대체된다.

### Flexible Congestion Control

QUIC는 플러그형 정체 제어와 TCP보다 풍부한 신호를 가지고 있어 QUIC가 TCP보다 더 풍부한 정보를 혼잡 제어 알고리즘에 제공할 수 있다. 현재, 기본 혼잡 통제는 TCP 큐빅의 재구현이다. 우리는 현재 대체 접근법을 실험하고 있다.

더 풍부한 정보의 한 예는 원래 패킷과 재전송 패킷 모두 새로운 패킷 시퀀스 번호를 가지고 있다는 것이다. 이를 통해 QUIC 송신자는 재전송을 위한 ACK와 원래 전송을 위한 ACK를 구별할 수 있으므로 TCP의 재전송 모호성 문제를 피할 수 있다. QUIC ACK는 또한 패킷의 수신과 송신되는 수신 사이의 지연을 명시적으로 전달하며, 단조롭게 증가하는 패킷 번호와 함께, 정확한 왕복 시간(RTT) 계산을 가능하게 한다.

마지막으로 QUIC의 ACK 프레임은 최대 256개의 ack 블록을 지원하므로 QUIC는 TCP(SACK 포함)보다 재주문하는 데 더 탄력적일 뿐만 아니라 재주문 또는 손실이 있을 때 더 많은 바이트를 전선에 유지할 수 있다. 클라이언트와 서버 모두 피어가 수신한 패킷에 대한 보다 정확한 그림을 가지고 있다.

### Stream and Connection Flow Control

QUIC는 HTTP/2의 흐름 제어를 근접하게 따라 스트림 및 연결 수준 흐름 제어를 구현한다. QUIC의 스트림 레벨 흐름 제어는 다음과 같이 동작한다. QUIC 수신기는 데이터를 수신하려는 각 스트림 내의 절대 바이트 오프셋을 광고한다. 특정 스트림에서 데이터가 전송, 수신 및 전달될 때 수신기는 해당 스트림에 대한 광고된 오프셋 제한을 증가시키는 WINDOW_UPDATE 프레임을 전송하여 피어가 해당 스트림에 대해 더 많은 데이터를 전송할 수 있도록 한다.

QUIC는 스트림별 흐름 제어 외에도 QUIC 수신기가 연결에 할당하고자 하는 총 버퍼를 제한하기 위해 연결 수준 흐름 제어를 구현한다. 연결 흐름 제어는 스트림 흐름 제어와 같은 방식으로 작동하지만 전달된 바이트와 가장 높은 오프셋은 모두 모든 스트림에 걸쳐 집계된다.

TCP의 수신 창 자동화와 유사하게, QUIC는 스트림과 연결 흐름 제어기에 대한 흐름 제어 크레딧의 자동화를 구현한다. QUIC의 자동 조정은 송신자의 전송 속도를 제한하는 것으로 보일 경우 WINDOW_UPDATE 프레임당 전송되는 크레딧의 크기를 증가시키고, 수신 어플리케이션의 속도가 느릴 때 송신자를 구속한다.

### Multiplexing

TCP의 HTTP/2는 TCP의 헤드오프라인 차단으로 인해 어려움을 겪는다. HTTP/2는 TCP의 단일 바이테스트림 추상화에서 많은 스트림을 멀티플렉싱하므로, TCP 세그먼트의 손실은 후속 세그먼트에 캡슐화된 HTTP/2 스트림에 관계 없이 재전송이 도착할 때까지 모든 후속 세그먼트를 차단한다.

QUIC는 멀티플렉스 작동을 위해 처음부터 설계되었기 때문에, 개별 스트림의 데이터를 전송하는 손실 패킷은 일반적으로 특정 스트림에만 영향을 미친다. 각 스트림 프레임은 도착 시 즉시 해당 스트림에 급파될 수 있으므로 손실 없는 스트림이 계속 재조립되어 응용에 있어 전진할 수 있다.

Caveat: QUIC는 현재 헤더 프레임에만 헤드오프라인을 차단하는 전용 헤더 스트림(3)에서 HTTP/2 HPACK 헤더 압축을 통해 HTTP 헤더를 압축하고 있다.

### Authenticated and Encrypted Header and Payload

TCP 헤더는 전선에서 일반 텍스트로 나타나며 인증되지 않아 수신 창 조작 및 시퀀스 번호 덮어쓰기 등 TCP에 대한 주입 및 헤더 조작 문제가 자주 발생한다. 이들 중 일부는 활성 공격이지만, 다른 일부는 TCP 성능을 투명하게 개선하기 위해 네트워크의 미들박스들에 의해 사용되는 메커니즘이다. 그러나, "성능 향상" 미들박스조차도 MPTCP 설계와 후속 전개성 문제에서 관찰된 바와 같이, 전송 프로토콜의 진화 가능성을 효과적으로 제한하고 있다.


QUIC 패킷은 항상 인증되며 일반적으로 페이로드는 완전히 암호화된다. 암호화되지 않은 패킷 헤더의 부분은 제3자에 의한 패킷 주입이나 조작을 방해하기 위해 여전히 수신자에 의해 인증된다. QUIC는 엔드투엔드 통신의 미들박스 조작으로부터 연결을 보호한다.

Caveat: 연결을 재설정하는 PUBLIC_RESET 패킷은 현재 인증되지 않았다.

### Connection Migration

TCP 연결은 소스 주소, 소스 포트, 대상 주소 및 대상 포트의 4-toule로 식별된다. TCP와 관련하여 잘 알려진 문제는 연결이 IP 주소 변경(예: WiFi에서 셀룰러로 전환) 또는 포트 번호 변경(클라이언트의 NAT 바인딩이 만료되어 서버에서 볼 수 있는 포트 번호가 변경되는 경우)에서 살아남지 못한다는 점이다. MPTCP는 TCP에 대한 연결 마이그레이션 문제를 해결하지만, 여전히 미들박스 지원의 부족과 OS 구축의 부족으로 어려움을 겪고 있다. 

QUIC 연결은 클라이언트에 의해 무작위로 생성되는 64비트 연결 ID로 식별된다. QUIC는 IP 주소 변경과 NAT 재 바인딩에서도 살아남을 수 있다. 이러한 마이그레이션에서도 연결 ID는 동일하게 유지되기 때문이다. QUIC는 또한 마이그레이션 클라이언트가 패킷의 암호화 및 암호 해독에 동일한 세션 키를 계속 사용하기 때문에 마이그레이션 클라이언트에 대한 자동 암호화 검증 기능을 제공한다.

서버가 사용 후 삭제 포트를 사용하여 클라이언트에 패킷을 전송하는 경우와 같이 4-투플에 의해 연결이 명확히 식별되지 않는 경우, 와이어에 바이트를 저장하기 위해 연결 ID를 전송하지 않는 옵션이 있다.

## Packet Types and Formats

QUIC는 특수 패킷과 일반 패킷을 가지고 있다. 특수 패킷에는 버전 협상 패킷과 공개 재설정 패킷의 두 가지 유형이 있으며 프레임이 포함된 일반 패킷이 있다.

모든 QUIC 패킷은 IP 단편화를 방지하기 위해 경로의 MTU에 맞도록 크기를 조정해야 한다. 경로 MTU 검색은 진행 중인 작업이며, 현재 QUIC 구현에서는 IPv6에 대해 1350바이트의 최대 QUIC 패킷 크기를 사용하며, IPv4에 대해서는 1370을 사용한다.


### QUIC Public Packet Header

와이어의 모든 QUIC 패킷은 1 ~ 51바이트 크기의 공개 헤더로 시작한다. 공개 헤더의 와이어 형식은 다음과 같다.  

```
--- src
     0        1        2        3        4            8
+--------+--------+--------+--------+--------+---    ---+
| Public |    Connection ID (64)    ...                 | ->
|Flags(8)|      (optional)                              |
+--------+--------+--------+--------+--------+---    ---+

     9       10       11        12   
+--------+--------+--------+--------+
|      QUIC Version (32)            | ->
|         (optional)                |                           
+--------+--------+--------+--------+


    13       14       15        16      17       18       19       20
+--------+--------+--------+--------+--------+--------+--------+--------+
|                        Diversification Nonce                          | ->
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+

    21       22       23        24      25       26       27       28
+--------+--------+--------+--------+--------+--------+--------+--------+
|                   Diversification Nonce Continued                     | ->
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+

    29       30       31        32      33       34       35       36
+--------+--------+--------+--------+--------+--------+--------+--------+
|                   Diversification Nonce Continued                     | ->
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+

    37       38       39        40      41       42       43       44
+--------+--------+--------+--------+--------+--------+--------+--------+
|                   Diversification Nonce Continued                     | ->
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+


    45      46       47        48       49       50
+--------+--------+--------+--------+--------+--------+
|           Packet Number (8, 16, 32, or 48)          |
|                  (variable length)                  |
+--------+--------+--------+--------+--------+--------+

---
```

페이로드에는 아래에 설명된 다양한 유형의 헤더 바이트가 포함될 수 있다.
공개 헤더의 필드는 다음과 같다.
- 공용 플래그:
 - 0x01 = PUBLIC_FLAG_VERSION. 이 플래그의 해석은 패킷이 서버에 의해 전송되는지 클라이언트에 의해 전송되는지에 따라 달라진다. 클라이언트가 전송한 경우, 헤더에 QUIC 버전이 포함되어 있음을 설정한다(아래 참조). 제안된 버전에 동의하는 서버로부터의 확인이 클라이언트에 의해 수신될 때까지 이 비트는 모든 패킷에 클라이언트에 의해 설정되어야 한다. 서버는 이 비트를 설정하지 않고 패킷을 전송하여 버전에 대한 동의를 표시한다. 서버에서 이 비트를 설정하면 패킷은 버전 협상 패킷이다. 버전 협상은 나중에 더 자세히 설명된다.
 - 0x02 = PUBLIC_FLAG_RESET. 패킷이 공용 재설정 패킷임을 나타내도록 설정한다.
 - 0x04 = 헤더에 32바이트 다변화 nce가 존재함을 나타낸다.
 - 0x08 = 패킷에 전체 8바이트 연결 ID가 존재함을 나타낸다. 이는 주어진 방향에 대해 다른 값으로 협상될 때까지 모든 패킷에서 설정되어야 한다(예: 클라이언트가 더 적은 바이트의 연결 ID가 표시되도록 요청할 수 있음). 
 - 0x30의 2비트는 각 패킷에 존재하는 패킷 번호의 저차 바이트 수를 나타낸다. 비트는 프레임 패킷에만 사용된다. 패킷 번호가 없는 공개 재설정 및 버전 협상 패킷(서버에서 전송)의 경우, 이 비트는 사용되지 않으며 반드시 0으로 설정해야 한다. 이 2비트 마스크 내에서:
  - 0x30은 패킷 번호의 6바이트가 존재함을 나타냄
  - 0x20은 패킷 번호의 4바이트가 존재함을 나타냄
  - 0x10은 패킷 번호의 2바이트가 존재함을 나타냄
  - 0x00은 패킷 번호의 1바이트가 존재함을 나타냄
  - 0x40은 다중 경로 사용을 위해 예약되어 있다.
  - 0x80은 현재 사용되지 않으며 0으로 설정해야 한다.
- 연결 ID: 클라이언트가 선택한 64비트 통계적으로 랜덤 번호로, 연결의 식별자입니다. QUIC 연결은 클라이언트가 로밍하더라도 계속 설정되도록 설계되어 있기 때문에 IP 4-투플(소스 IP, 소스 포트, 대상 IP, 대상 포트)은 연결을 식별하기에 불충분할 수 있다. 각 전송방향에 대해, 4-투플이 접속을 식별하기에 충분할 경우, 접속 ID를 생략할 수 있다.
- QUIC 버전: QUIC 프로토콜 버전을 나타내는 32비트 불투명 태그. 공용 플래그가 FLAG_VERSION(즉, public_flags & FLAG_VERSION !=0)을 포함하는 경우에만 표시하십시오. 클라이언트는 이 플래그를 설정하고 제안된 버전 하나만 포함하며 임의 데이터도 포함할 수 있다(이 버전에 적합). 서버는 클라이언트 제안 버전이 지원되지 않을 때 이 플래그를 설정하고 허용 가능한 버전의 목록(0 또는 그 이상)을 제공할 수 있지만, 버전 이후에 어떠한 데이터도 포함해서는 안 된다. 최근의 실험 버전에서 버전 값의 예로는 'Q'를 포함하는 바이트 9, '0'을 포함하는 바이트 10 등에 해당하는 "Q025" 등이 있다[이 문서의 끝에 나열된 다양한 버전에 대한 변경 목록 참조].
- 패킷 번호: 패킷 번호의 하위 8, 16, 32 또는 48 비트, 어떤 FLAG_를 기반으로 하는가?BYTE_SEQUENCE_NUMBER 플래그가 공용 플래그에 설정된다. 각 일반 패킷(특수 공개 재설정 및 버전 협상 패킷과 반대로)은 송신자에 의해 패킷 번호를 할당받는다. 엔드포인트가 보낸 첫 번째 패킷은 1의 패킷 번호를 가져야 하며, 각각의 후속 패킷은 이전 패킷의 패킷 번호보다 큰 패킷 번호를 가져야 한다.

패킷 번호의 하위 64비트는 암호화 비ce의 일부로 사용되므로, QUIC 끝점은 64비트로 나타낼 수 없는 패킷 번호를 가진 패킷을 전송해서는 안 된다. QUIC 끝점이 패킷 번호(2^64-1)를 가진 패킷을 전송하는 경우, 해당 패킷은 CONNECT를 포함해야 한다.QUIC_SEQUENCE_NUMBER_LIMIT_REACHED 오류 코드가 있는 ION_CLOSE 프레임은 엔드포인트가 추가 패킷을 전송하지 않아야 한다.

패킷 번호의 하위 48비트가 전송된다. 수신자에 의한 패킷 번호의 모호하지 않은 재구성을 가능하게 하기 위해서, QUIC 끝점은 수신자가 송신을 한 것으로 알려진 가장 큰 패킷 번호(2^(비트길이-2)보다 패킷 번호가 큰 패킷을 전송해서는 안 된다. 따라서, 비행 중에는 (2^46) 패킷 이상이 없어야 한다.

잘린 패킷 번호는 원래 잘린 패킷 번호를 포함하고 있던 패킷을 전송한 엔드포인트의 가장 큰 알려진 패킷 번호보다 하나 이상 가장 가까운 값을 가지는 것으로 추론해야 한다. 패킷 번호의 전송된 부분은 추론된 값의 가장 낮은 비트와 일치한다.

__6PAGE__